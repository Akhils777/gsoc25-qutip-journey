[
  {
    "objectID": "posts/intro/index.html",
    "href": "posts/intro/index.html",
    "title": "Excited to Join GSoC 2025 with QuTiP-QOC!",
    "section": "",
    "text": "I am incredibly excited to announce that I have been selected for Google Summer of Code (GSoC) 2025 with the QuTiP community! This is a fantastic opportunity to deepen my understanding of quantum optimal control and contribute to a cutting-edge open-source project.\nIn this blog series, I will share my weekly progress, the challenges I face, how I overcome them, and my plans moving forward. To kick off, here is an overview of the project and its key goals."
  },
  {
    "objectID": "posts/intro/index.html#project",
    "href": "posts/intro/index.html#project",
    "title": "Excited to Join GSoC 2025 with QuTiP-QOC!",
    "section": "Project",
    "text": "Project\nThe project I will be working on is titled ‚ÄúQuTiP-QOC: Advancing Quantum Optimal Control Algorithms‚Äù.\n\nProblem Statement\nThis project proposes the direct integration of advanced quantum optimal control algorithms‚ÄîGRAPE (Gradient Ascent Pulse Engineering), CRAB (Chopped Random Basis), JOPT (Joint Optimization), and GOAT (Gradient Optimization of Analytic Controls)‚Äîinto the qutip-qoc package, eliminating its current dependency on the separate qutip-qtrl library.\nBy re-implementing these algorithms in a modular, maintainable, and efficient manner‚Äîleveraging QuTiP‚Äôs core functionality‚Äîthis project aims to modernize and unify the quantum control stack within QuTiP. This integration will provide a streamlined, flexible foundation that supports state-of-the-art optimization methods and improved numerical performance.\nMoreover, this work sets the stage for replacing dependencies in related projects such as qutip-qip, moving from qutip-qtrl to qutip-qoc. This transition will enable greater flexibility and the adoption of more advanced and varied optimization techniques for precise quantum circuit control and manipulation.\nObjectives\n\nIntegrate a standalone FidelityComputer system to replace legacy fidelity computation methods, improving modularity and maintainability.\n\nSupport multiple fidelity types including PSU, SU, and TRACEDIFF, and handle both state and process fidelities.\n\nAchieve compatibility with JAX to enable accelerated numerical computation and differentiation.\n\nRefactor existing optimization algorithms (e.g., GRAPE, CRAB) to utilize the new fidelity system for improved performance and flexibility.\n\nEnsure numerical consistency with the legacy fidelity module and maintain backward compatibility.\n\nActively work to resolve currently failing test cases related to state-to-state and parameterized optimizations.\n\nDocument the new fidelity system thoroughly and provide example notebooks to help users adopt the improved framework.\n\nMentors\n\nAlex Pitchford\n\nBoxi Li"
  },
  {
    "objectID": "posts/intro/index.html#why-this-project-matters",
    "href": "posts/intro/index.html#why-this-project-matters",
    "title": "Excited to Join GSoC 2025 with QuTiP-QOC!",
    "section": "Why this project matters?",
    "text": "Why this project matters?\nQuantum optimal control plays a critical role in manipulating quantum systems with high precision, which is essential for quantum computing, sensing, and communication technologies. By improving QuTiP-QOC‚Äôs algorithms and modularizing fidelity computations, this project will help researchers and developers design and analyze quantum control sequences more efficiently.\nThe enhanced fidelity system will provide a flexible, maintainable foundation for future algorithm development and integration with high-performance computing tools. Ultimately, this project will contribute to accelerating advancements in quantum computing by enabling more precise and accessible quantum control solutions.\n\nStay tuned for weekly updates on my journey through this exciting project. I look forward to sharing what I learn and build over the summer!"
  },
  {
    "objectID": "posts/Coding week 6/index.html",
    "href": "posts/Coding week 6/index.html",
    "title": "Week 6",
    "section": "",
    "text": "What did I do this week?\nThis week, I focused on resolving compatibility issues caused by the recent upgrade to jax==0.6.2. The update removed internal access to attributes like jaxlib.xla_extension.PjitFunction and pxla._xla.PjitFunction, which previously allowed us to identify JAX-compiled functions. This change caused test failures due to broken type checks.\nTo resolve the issue, I updated the result.py module by replacing the old type-checking logic with a safer alternative:\n_jitfun_type = type(jax.jit(lambda x: x))\nThis avoids reliance on private APIs and ensures future-proof compatibility across JAX versions.\nI re-verified the failing tests with the updated `qutip-jax` installed, and **all tests now pass**.\n\n\n\nPull Request Progress\nAfter completing the fix, I addressed all pending review comments, removed unnecessary print and debug statements, and wrapped up the final discussion point. I then submitted the pull request, which successfully passed all tests.\n\n\n\nQTRL Logging Cleanup in QOC\nAlongside the JAX fix, I continued working on the QTRL-to-QOC migration effort by cleaning up legacy logging code in QOC‚Äôs optimizer modules.\n\nüîß Specifically, I:\n\nRemoved QTRL-specific logging usage from _grape.py and _crab.py.\nEliminated:\n\nimport qutip_qtrl.logging_utils\nlogger = logging.get_logger()\nAll logger.debug(...) calls\n\n\nI ensured that surrounding logic tied to self._qtrl.stats, self._qtrl.iter_summary, and self._qtrl.dump remained untouched, so functionality was preserved even as unused logging code was removed.\nAfter making these changes, I ran the full test suite and confirmed that all tests passed.\n\nI‚Äôm excited to be moving closer to a cleaner, more modular, and JAX-compatible QOC codebase that‚Äôs easier to maintain and extend for future optimizers."
  },
  {
    "objectID": "posts/Coding Week 4/index.html",
    "href": "posts/Coding Week 4/index.html",
    "title": "Week 4",
    "section": "",
    "text": "Following last week‚Äôs investigation into Issue #47, where the JOPT algorithm fails for open-system state transfer using the TRACEDIFF fidelity type, I revisited and reworked the proposed solution based on mentor feedback.\nIn my initial PR, I attempted to fix the bug by manually constructing the adjoint using:\nQobj(diff.data.adjoint(), dims=Dimensions(diff.dims[1], diff.dims[0]), copy=False)\nDuring our weekly meeting, we discussed that the Dimensions class doesn‚Äôt exist in the version of QuTiP (v5.1) used in qutip-qoc. This prompted us to explore simpler, version-compatible alternatives.\n\n\n@BoxiLi suggested that since diff is already a Qobj, we can simply take the adjoint using:\ndiff_dag = diff.dag()\nAlex agreed with this direction, noting that ‚Äúperhaps all we need is an appropriately placed .dag()‚Äù.\n\n\n\nWe replaced the manual adjoint with:\ndiff_dag = diff.dag()\ng = 0.5 * (diff_dag * diff).tr()\nHowever, this caused compatibility issues with JAX. Specifically, calling .tr() raised an AttributeError because the underlying object became a DynamicJaxprTracer, which doesn‚Äôt support typical QuTiP methods like .tr(), .full(), or .data.trace().\n\n\n\nTo address the issue, I am now exploring a JAX-compatible alternative that uses raw JAX array operations instead of QuTiP methods. For example:\nimport jax.numpy as jnp\n\ng = 0.5 * jnp.trace(jnp.matmul(diff_dag._jxa, diff._jxa))\nOur goal is to: - ‚úÖ Maintain a minimal patch size (as mentors prefer) - üîÑ Avoid QuTiP internals that break with JAX tracing - ‚öôÔ∏è Preserve logic correctness for density matrices in Liouville space\n\n\n\nThe updated fix is being tested on a minimal open-system JOPT use case that previously failed with TRACEDIFF. The test is verifying that:\n\ndiff.dag() behaves as expected\nThe fidelity value is computed via JAX-compatible expressions\nThe new logic doesn‚Äôt introduce new shape or gradient issues\n\n\n\n\n\nI also began early experiments to explore the dependency and fidelity logic in qutip-qtrl. This included:\n\nIdentifying key parts of qtrl that overlap with qutip-qoc\nExperimentally copying selected fidelity-related files from qtrl into the qutip-qoc codebase\nTesting whether they can be made to work as a proof-of-concept, potentially as part of a future unification\n\nThis is just a trial, but it helps identify where tight coupling exists and what effort would be required to integrate or migrate logic more formally."
  },
  {
    "objectID": "posts/Coding Week 4/index.html#mentor-suggestions",
    "href": "posts/Coding Week 4/index.html#mentor-suggestions",
    "title": "Week 4",
    "section": "",
    "text": "@BoxiLi suggested that since diff is already a Qobj, we can simply take the adjoint using:\ndiff_dag = diff.dag()\nAlex agreed with this direction, noting that ‚Äúperhaps all we need is an appropriately placed .dag()‚Äù."
  },
  {
    "objectID": "posts/Coding Week 4/index.html#what-i-tried",
    "href": "posts/Coding Week 4/index.html#what-i-tried",
    "title": "Week 4",
    "section": "",
    "text": "We replaced the manual adjoint with:\ndiff_dag = diff.dag()\ng = 0.5 * (diff_dag * diff).tr()\nHowever, this caused compatibility issues with JAX. Specifically, calling .tr() raised an AttributeError because the underlying object became a DynamicJaxprTracer, which doesn‚Äôt support typical QuTiP methods like .tr(), .full(), or .data.trace()."
  },
  {
    "objectID": "posts/Coding Week 4/index.html#what-i-am-doing-now",
    "href": "posts/Coding Week 4/index.html#what-i-am-doing-now",
    "title": "Week 4",
    "section": "",
    "text": "To address the issue, I am now exploring a JAX-compatible alternative that uses raw JAX array operations instead of QuTiP methods. For example:\nimport jax.numpy as jnp\n\ng = 0.5 * jnp.trace(jnp.matmul(diff_dag._jxa, diff._jxa))\nOur goal is to: - ‚úÖ Maintain a minimal patch size (as mentors prefer) - üîÑ Avoid QuTiP internals that break with JAX tracing - ‚öôÔ∏è Preserve logic correctness for density matrices in Liouville space"
  },
  {
    "objectID": "posts/Coding Week 4/index.html#testing",
    "href": "posts/Coding Week 4/index.html#testing",
    "title": "Week 4",
    "section": "",
    "text": "The updated fix is being tested on a minimal open-system JOPT use case that previously failed with TRACEDIFF. The test is verifying that:\n\ndiff.dag() behaves as expected\nThe fidelity value is computed via JAX-compatible expressions\nThe new logic doesn‚Äôt introduce new shape or gradient issues"
  },
  {
    "objectID": "posts/Coding Week 4/index.html#experimental-qtrl-integration",
    "href": "posts/Coding Week 4/index.html#experimental-qtrl-integration",
    "title": "Week 4",
    "section": "",
    "text": "I also began early experiments to explore the dependency and fidelity logic in qutip-qtrl. This included:\n\nIdentifying key parts of qtrl that overlap with qutip-qoc\nExperimentally copying selected fidelity-related files from qtrl into the qutip-qoc codebase\nTesting whether they can be made to work as a proof-of-concept, potentially as part of a future unification\n\nThis is just a trial, but it helps identify where tight coupling exists and what effort would be required to integrate or migrate logic more formally."
  },
  {
    "objectID": "posts/Coding Begins week 2/index.html",
    "href": "posts/Coding Begins week 2/index.html",
    "title": "Week#2",
    "section": "",
    "text": "What did I do this week?\nOver the past week, I‚Äôve been working on analyzing two open issues in the QuTiP-QOC GitHub repository, as discussed in our weekly meeting. These issues highlight important discrepancies in the behavior of optimization algorithms for open quantum systems and represent a significant opportunity to improve reliability and correctness.\n\n\nüìå Issue #47: JOPT Fails for Open-System State Transfer\nSummary:\nWhen using the JOPT algorithm to solve a simple open-system state transfer problem (qubit from ground to excited state), the optimization crashes with a ValueError related to a dimension mismatch in the Liouville representation.\nFindings: - The issue arises during the construction of the adjoint of a matrix difference in the JOPT fidelity computation. - The mismatch in shapes ((4, 1) vs (1, 4)) suggests a bug in how the density matrix difference is reshaped and handled in Liouville space. - Notably, the exact same control setup works fine with GOAT, indicating that this is a JOPT-specific bug.\nüëâ View Issue #47\n\n\n\nüìå Issue #46: GRAPE Infidelity Mismatch\nSummary:\nThe GRAPE algorithm reports a final infidelity below the target threshold (0.0008), but manual simulation using the optimized control returns a significantly worse infidelity (0.0038).\nFindings: - Manual evolution was independently verified using both exponential propagators and mesolve, and the results are consistent. - This suggests that GRAPE either overestimates fidelity internally or there‚Äôs a bug in its cost function or propagation logic. - A ~300% mismatch raises concerns about the reliability of convergence metrics, especially in open-system scenarios.\nüëâ View Issue #46\n\n\n\n\nPlan for next week?\nNext week, I‚Äôll focus on:\n\nDigging deeper into the JOPT dimension mismatch in open-system Liouville space dynamics (Issue #47) and verifying reshaping logic and adjoint consistency\nInvestigating GRAPE‚Äôs fidelity evaluation pathway (Issue #46) to locate possible discrepancies in how cost values are tracked or computed internally\nPrototyping potential fixes in a sandboxed environment without affecting core modules\nDepending on the outcome of these investigations, I plan to raise a PR addressing one or both issues if the proposed fixes prove reliable and non-breaking\n\n\n‚ÄúI‚Äôm motivated by the opportunity to resolve foundational bugs and improve reliability in QuTiP-QOC‚Äôs optimization backend ‚Äî each fix brings us closer to a more robust and trustworthy control framework.‚Äù"
  },
  {
    "objectID": "posts/before-coding-begins/index.html",
    "href": "posts/before-coding-begins/index.html",
    "title": "Before-Coding-Begins",
    "section": "",
    "text": "What did I do this week?\nThis week, I worked further on resolving Issue #10, which involves replacing the legacy qutip_qtrl.fid_computer with a modern and modular FidelityComputer class designed for quantum optimal control workflows.\nPreviously, I had submitted a preliminary version of this class supporting multiple fidelity types (PSU, SU, TRACEDIFF) and ensuring compatibility with JAX for automatic differentiation. However, based on further reflection, I decided to hold off on raising a pull request and instead focused on polishing the implementation.\nThe major highlight of the week was addressing the previously failing test cases for:\n\nState-to-state GRAPE optimization\nState-to-state CRAB optimization\nParameterized CRAB optimization\n\nThese failures were caused by subtle differences in fidelity expectations and numerical tolerances when switching to the new engine. I resolved them by:\n\nEnsuring consistent handling of input shapes and data types\nCarefully aligning fidelity formulae with the expected definitions in the test suite\nImproving numerical precision and tolerances where required\n\nAs a result, all tests now pass, including the edge cases that initially failed.\nBeyond that, the direction I‚Äôve been shaping for the FidelityComputer revolves around:\n\nModular structure: With clearer separation of state, process, and map fidelities in mind, the aim is to make each component independently extensible and easier to maintain.\nBatch support: Handling multiple quantum states or unitaries efficiently has been central to the design approach, and continues to shape how I think about scaling and performance.\nCleaner integration: Ensuring compatibility with GRAPE, CRAB, and other optimization methods remains a key goal ‚Äî something I‚Äôve been aligning the implementation toward as the project evolves.\n\nWhile the code is functionally complete, I plan to further refine and customize certain parts before raising the pull request.\n\n\nPlan for next week?\nNext week, I‚Äôll focus on:\n\nStudying the relevant sections from Alex‚Äôs PhD thesis ‚Äî especially Section 1.6: Quantum control function optimisation ‚Äî to deepen my understanding of GRAPE\nFinalizing and cleaning up the FidelityComputer interface\nContributing to documentation improvements as part of Issue #13, particularly:\n\nInvestigating the broken search functionality on the QuTiP-QOC documentation site\n\nRaising a well-documented and review-ready pull request\n\n\nI‚Äôm excited to be moving closer to a stable and efficient fidelity framework that can serve as the backbone of QuTiP-QOC‚Äôs optimization tools."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Akhil Pratap Singh",
    "section": "",
    "text": "Know more about me, [here]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GSOC25-QUTIP-QOC-JOURNEY",
    "section": "",
    "text": "Week 6\n\n\n\n\n\n\n\n\nJul 8, 2025\n\n\nAkhil Pratap Singh\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 5\n\n\n\n\n\n\n\n\nJul 1, 2025\n\n\nAkhil Pratap Singh\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 4\n\n\n\n\n\n\n\n\nJun 24, 2025\n\n\nAkhil Pratap Singh\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 3: Fixing Dimension Mismatch and Investigating GRAPE Fidelity Issues\n\n\n\n\n\n\n\n\nJun 17, 2025\n\n\nAkhil Pratap Singh\n\n\n\n\n\n\n\n\n\n\n\n\nWeek#2\n\n\n\n\n\n\n\n\nJun 10, 2025\n\n\nAkhil Pratap Singh\n\n\n\n\n\n\n\n\n\n\n\n\nCoding Begins! Week#1\n\n\n\n\n\n\n\n\nJun 5, 2025\n\n\nAkhil Pratap Singh\n\n\n\n\n\n\n\n\n\n\n\n\nBefore-Coding-Begins\n\n\n\n\n\n\n\n\nMay 27, 2025\n\n\nAkhil Pratap Singh\n\n\n\n\n\n\n\n\n\n\n\n\nCommunity Bonding and Initial Contributions\n\n\n\n\n\n\n\n\nMay 16, 2025\n\n\nAkhil Pratap Singh\n\n\n\n\n\n\n\n\n\n\n\n\nExcited to Join GSoC 2025 with QuTiP-QOC!\n\n\n\n\n\n\n\n\nMay 9, 2025\n\n\nAkhil Pratap Singh\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Coding Begins week 1/index.html",
    "href": "posts/Coding Begins week 1/index.html",
    "title": "Coding Begins! Week#1",
    "section": "",
    "text": "What did I do this week?\nThis week, I focused on two important areas: deepening my understanding of the GRAPE algorithm and working on the QuTiP-QOC documentation system.\nüìò Studying GRAPE from Alex‚Äôs PhD Thesis\nAs planned, I studied Section 1.6: Quantum control function optimisation from [Alex‚Äôs PhD thesis]. This section provided a clear and compact overview of gradient-based control optimization techniques in open quantum systems. The insights from this theory helped me better understand how GRAPE is structured and how its gradients behave under Lindblad dynamics ‚Äî which is crucial for aligning implementation with mathematical expectations.\nüõ†Ô∏è Fixing the Documentation Search Issue\nI also worked on Issue #13, specifically the part about the search functionality being broken on the documentation website.\nHere‚Äôs what I discovered:\n\nWhen building the documentation locally using the officially supported Sphinx setup (make html in the doc/ directory), the search functionality works as expected.\nHowever, when I visited the published documentation site and tried to search for any term, the search bar keeps showing ‚ÄúSearching‚Ä¶‚Äù indefinitely and never returns any results.\n\nWe discussed this during our chat, and I showed the working version on my local machine. Based on that, we suspected the problem might be due to JavaScript dependencies like jQuery not being correctly loaded in the deployed environment. As a potential fix, I modified the conf.py file to explicitly include jQuery:\n```python html_js_files = [ ‚Äòhttps://code.jquery.com/jquery-3.6.0.min.js‚Äô,]\n\n \n\n\nLocalhost (Working) Live Website (Broken)\n\n\n\nPlan for next week\nNext week, I‚Äôll focus on:\n\nReproducing and analyzing Issue #47, which involves a dimension mismatch error in JOPT during fidelity computation in Liouville space.\nInvestigating Issue #46, where GRAPE reports inaccurate fidelity results compared to manual simulations.\n\n\nI‚Äôm looking forward to tackling these deeper optimization challenges while strengthening the documentation that will support future contributors."
  },
  {
    "objectID": "posts/Coding week 3/index.html",
    "href": "posts/Coding week 3/index.html",
    "title": "Week 3: Fixing Dimension Mismatch and Investigating GRAPE Fidelity Issues",
    "section": "",
    "text": "What did I do this week?\n\nüõ†Ô∏è Fixing Dimension Mismatch in Open-System TRACEDIFF (Issue #47)\nThis week, I continued work on Issue #47, where the JOPT algorithm failed in open-system state transfer problems using the TRACEDIFF fidelity type.\nTo resolve this, I proposed a solution by modifying the _infid() function to handle density matrices and state vectors uniformly, using JAX-compatible logic to compute the infidelity depending on whether the final state is a vector or a square matrix.\nI submitted a pull request with the initial fix. After receiving feedback from @BoxiLi, I realized the root cause was an incorrect dimension specification when constructing the adjoint of a Qobj. Specifically, I had reused diff.dims while taking diff.data.adjoint(), which led to mismatches like [[4], [1]] instead of the expected [[1], [4]].\nBoxi pointed out that updating the dimensions after taking the adjoint ‚Äî as done in QuTiP‚Äôs dag() ‚Äî would be more robust.\n‚úÖ The fix was revised to:\n```python Qobj(diff.data.adjoint(), dims=Dimensions(diff.dims[1], diff.dims[0]), copy=False)\n\n\nInvestigating GRAPE Infidelity Mismatch (Issue #46)\nI also began investigating Issue #46, where the GRAPE algorithm reports a significantly lower infidelity than what is observed via manual simulation in an open-system qubit control problem.\nWhat I Did: Reproduced the issue locally using the script provided in the GitHub issue.\nConfirmed that GRAPE reports an infidelity of 0.0008, while manual evolution with the optimized control yields 0.0038 ‚Äî clearly violating the fidelity target.\nImplemented a custom TRACEDIFF fidelity function using Liouville space formalism, and verified that this discrepancy is consistent and reproducible.\n\nFindings: The mismatch isn‚Äôt just numerical noise ‚Äî it suggests that GRAPE is using a fidelity formula suited for closed systems or pure states.\n\nThis formulation likely originates from qutip-qtrl and seems to have been carried over to qutip-qoc incorrectly for open systems.\n\nSuspicions (To Be Confirmed): The root cause may lie in the fidelity logic within grape.py or FidelityComputer, which doesn‚Äôt correctly account for density matrices under dissipation.\n\nThis discrepancy undermines the validity of GRAPE‚Äôs convergence metrics in open-system problems.\n\n\n\nPlan for next week\n\nTry out BL‚Äôs suggested improvements on Issue #47 to further refine the TRACEDIFF fidelity fix.\nInvestigate the relationship between fidelity measures used in qutip-qtrl and those currently implemented in qutip-qoc, as discussed in Issue #46.\nBegin exploring how qtrl‚Äôs fidelity logic could be adapted into qutip-qoc by:\nIdentifying key dependency points between the two,\nExperimentally copying over relevant fidelity-related files from Qtrl into QOC and attempting to make them work as a proof-of-concept.\n\n\nI‚Äôm excited to keep digging into these deeper architectural connections between Qtrl and QOC, as they could lay the groundwork for a unified and more reliable optimization framework in QuTiP."
  },
  {
    "objectID": "posts/Coding week 5/index.html",
    "href": "posts/Coding week 5/index.html",
    "title": "Week 5",
    "section": "",
    "text": "This week, I tackled Issue #47, where the JOPT optimizer failed on open-system state transfer tasks. The root cause was a dimension mismatch when reconstructing a Qobj inside a JAX-traced function:\ndiff_dag = Qobj(diff.data.adjoint(), dims=diff.dims)\ng = 0.5 * (diff_dag * diff).data.trace()\nThis approach didn‚Äôt play well with JAX‚Äôs tracing mechanism, especially under jit and batch execution. To resolve it, I replaced it with a fully JAX-native computation:\ndiff_dag = diff.dag()\ng = 0.5 * jnp.trace(diff_dag.data._jxa @ diff.data._jxa)\nThis avoids any fallback to Qobj() constructors or .trace() methods, which are incompatible during JAX tracing. I tested this thoroughly under both jit and batch modes, and it worked as expected.\n\n\n\nAfter raising the PR, I encountered failing tests. The cause? A silent upgrade to jax==0.6.2, which introduces a breaking change: the internal jaxlib.xla_extension (used by some parts of QuTiP) was removed or changed. This means anything depending on PjitFunction inside xla_extension fails silently or raises obscure runtime errors."
  },
  {
    "objectID": "posts/Coding week 5/index.html#catch-version-incompatibility-after-raising-pr",
    "href": "posts/Coding week 5/index.html#catch-version-incompatibility-after-raising-pr",
    "title": "Week 5",
    "section": "",
    "text": "After raising the PR, I encountered failing tests. The cause? A silent upgrade to jax==0.6.2, which introduces a breaking change: the internal jaxlib.xla_extension (used by some parts of QuTiP) was removed or changed. This means anything depending on PjitFunction inside xla_extension fails silently or raises obscure runtime errors."
  },
  {
    "objectID": "posts/Coding week 5/index.html#step-1-preparing-the-staging-environment-q2",
    "href": "posts/Coding week 5/index.html#step-1-preparing-the-staging-environment-q2",
    "title": "Week 5",
    "section": "Step 1: Preparing the Staging Environment (q2/)",
    "text": "Step 1: Preparing the Staging Environment (q2/)\nTo enable clean experimentation, I created a q2/ folder under src/qutip_qoc/, which serves as a sandbox for integrating logic from qutip-qtrl.\nI copied the following key modules from QTRL that are essential to GRAPE:\n\ndynamics.py\nfidcomp.py\ndump.py\ngrape.py\npulsegen.py\noptimizer.py\noptimresult.py"
  },
  {
    "objectID": "posts/Coding week 5/index.html#step-2-analyzing-_grape.py-in-qoc",
    "href": "posts/Coding week 5/index.html#step-2-analyzing-_grape.py-in-qoc",
    "title": "Week 5",
    "section": "Step 2: Analyzing _grape.py in QOC",
    "text": "Step 2: Analyzing _grape.py in QOC\nI explored the existing _grape.py file in QOC, which provides a GRAPE interface but still relies on QTRL‚Äôs Optimizer class. It wraps .infidelity() and .gradient() methods but accesses fid_computer and control amplitudes indirectly via self._qtrl, a deeply coupled structure.\n\nStep 3: Initial Cleanup ‚Äî Removed QTRL Logging\nFollowing Boxi‚Äôs suggestion, I began the refactoring by removing the QTRL-specific logging setup from _grape.py.\nThis included:\n\nRemoving import qutip_qtrl.logging_utils as logging\nRemoving logger = logging.get_logger()\nDeleting all logger.debug(...) lines and if self._qtrl.log_level &lt;= logging.DEBUG: checks\n\nI did not touch the rest of the code structure ‚Äî everything else like self._qtrl.stats, self._qtrl.dump, and self._qtrl.iter_summary was left intact.\nAfter this cleanup, I reran the tests to confirm that removing logging had no effect on core functionality. All tests passed, indicating it was safe to proceed with further modularization later.\n\nI‚Äôm excited to be moving closer to a modular and JAX-compatible optimization framework that aligns with the goals of QuTiP-QOC and supports robust open-system quantum control."
  },
  {
    "objectID": "posts/community-bond/index.html",
    "href": "posts/community-bond/index.html",
    "title": "Community Bonding and Initial Contributions",
    "section": "",
    "text": "What did I do this week?\nThis week, I focused on immersing myself deeply into the QuTiP-QOC codebase to understand the architecture and workflows, especially around the fidelity calculation system which is critical for quantum optimal control algorithms. I carefully read through the documentation and explored the repository, including related issues and pull requests, to grasp how different modules interact.\nA major highlight was working on Issue #10, where I contributed a Pull Request to integrate a new FidelityComputer system that replaces the old qutip_qtrl.fid_computer dependency. This new system introduces support for PSU, SU, and trace difference fidelity types, adds state and process fidelity calculations, and ensures compatibility with JAX for automatic differentiation.\nWhile the PR is a work-in-progress with three failing test cases (state-to-state GRAPE and CRAB optimizations, and parameterized CRAB), the rest of the tests show numerical consistency and improved fidelity handling. This refactoring will help make the optimization algorithms more robust and maintainable.\nAdditionally, I set up my development environment, ran existing test suites, and planned how to address the failing tests in the upcoming weeks. I also connected with my mentors and the QuTiP-QOC community, which has been encouraging and insightful.\n\n\nPlan for next week?\nMy next goal is to fix the failing test cases related to state-to-state optimizations and parameterized CRAB algorithms. I will continue enhancing the fidelity module and work on expanding the test coverage to ensure the new system fully replaces the legacy one without regression.\n\nLooking forward to making steady progress and sharing updates as I dive deeper into quantum optimal control!"
  }
]